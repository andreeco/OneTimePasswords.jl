var documenterSearchIndex = {"docs":
[{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#OneTimePasswords.OneTimePasswords","page":"API","title":"OneTimePasswords.OneTimePasswords","text":"module OneTimePasswords\n\nA minimal, fast Julia module for generating and verifying counter-based (HOTP, RFC 4226), time-based (TOTP, RFC 6238), and challenge-response (OCRA, RFC 6287) one-time passwords.\n\nImplements RFCs 4226, 6238, and 6287. Compliance not guaranteed. Not audited.\n\nAlso provides provisioning URIs and QR-codes for authenticator apps.\n\nwarning: Warning\nSecurity notice: This library implements only the algorithmic core of HOTP, TOTP, and OCRA. It does not provide rate limiting, account lockouts, throttling, replay prevention, or secure memory features. Your application or service layer is responsible for these kind of  protections.OTP secrets are returned as Base32-encoded String values. In Julia, String objects are immutable and not cleared from memory after use; they may persist until garbage collection and can appear in memory dumps. For high-assurance use, consider storing secrets as Vector{UInt8} and explicitly overwriting them (with fill!) after use.\n\nTiming and Side-Channel Security\n\nOTP code comparisons are performed in constant time, mitigating the most common remote timing side-channel attacks.\nThis package does not guarantee constant-time execution for secret decoding, key handling, or cryptographic operations. It is not designed for hardware tokens, HSMs, or \"side-channel hardened\" use cases.\nFor most typical server deployments, this is sufficient. For high-assurance applications (e.g., multi-tenant or hostile environments, or where hardware side-channels are a concern), use a hardened library or a hardware security module (HSM).\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> secret = generate_secret();\n\njulia> code = generate(HOTP(), secret, 0; digits=6);\n\njulia> verify(HOTP(), secret, 0, code)\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(HOTP(), secret, account, issuer;\n               digits=6, counter=0, algorithm=:SHA1);\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \"hotp.svg\";\n\njulia> open(tmp_svg,\"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \"hotp.png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL\n\njulia> using OneTimePasswords, Dates\n\njulia> secret = generate_secret();\n\njulia> code = generate(TOTP(), secret; period=Second(30), digits=6);\n\njulia> verify(TOTP(), secret, code; allowed_drift=Second(30))\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(TOTP(), secret, account, issuer; digits=6, \n       period=Second(30));\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \".svg\";\n\njulia> open(tmp_svg, \"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \".png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL\n\njulia> using OneTimePasswords, Dates\n\njulia> secret = generate_secret(64);\n\njulia> suite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\n\njulia> dt = DateTime(2020,1,1,0,0,30)\n2020-01-01T00:00:30\n\njulia> code = generate(OCRA(), secret;\n                          suite=suite,\n                          challenge=\"SIG1400000\",\n                          timestamp=dt,\n                          digits=8,\n                          algorithm=:SHA512);\n\njulia> verify(OCRA(), secret, code;\n               suite=suite,\n               challenge=\"SIG1400000\",\n               timestamp=dt + Second(60),\n               allowed_drift=Second(60),\n               digits=8,\n               algorithm=:SHA512)\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(OCRA(), secret, \"bob\", \"MyApp\";\n            suite=suite,\n            challenge=\"SIG1400000\",\n            timestamp=dt);\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \".svg\";\n\njulia> open(tmp_svg, \"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \".png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL\n\nSee also generate_secret, AbstractOTP, HOTP,  TOTP, OCRA,  generate, verify  uri and qrcode.\n\n\n\n\n\n","category":"module"},{"location":"api/#OneTimePasswords.AbstractOTP","page":"API","title":"OneTimePasswords.AbstractOTP","text":"AbstractOTP\n\nAbstract supertype for one-time-password generators.\n\n\n\n\n\n","category":"type"},{"location":"api/#OneTimePasswords.HOTP","page":"API","title":"OneTimePasswords.HOTP","text":"HOTP()\n\nCounter-based OTP (RFC 4226).\n\n\n\n\n\n","category":"type"},{"location":"api/#OneTimePasswords.OCRA","page":"API","title":"OneTimePasswords.OCRA","text":"OCRA()\n\nThe OATH Challenge-Response Algorithm (RFC 6287).\n\n\n\n\n\n","category":"type"},{"location":"api/#OneTimePasswords.TOTP","page":"API","title":"OneTimePasswords.TOTP","text":"TOTP()\n\nTime-based OTP (RFC 6238).\n\n\n\n\n\n","category":"type"},{"location":"api/#OneTimePasswords._build_ocra_message","page":"API","title":"OneTimePasswords._build_ocra_message","text":"_build_ocra_message(\n    suite::AbstractString,\n    counter::Union{Nothing,Int}=nothing,\n    challenge::AbstractString=\"\",\n    passwordhash::AbstractString=\"\",\n    session_info::AbstractString=\"\",\n    timestamp::Union{Nothing,Int}=nothing)::Vector{UInt8}\n\nConstruct the binary “DataInput” value for OCRA (RFC 6287).\n\nThe overall layout is:\n\nDataInput = UTF8(suite) ‖ 0x00 ‖ [ C ] ‖ [ Q ] ‖ [ P ] ‖ [ S ] ‖ [ T ]\n\nwhere\n\nSuite: UTF-8 bytes of the suite string, then a 0x00 separator.\nC: 8-byte big-endian counter (if suite contains “C”).\nQ: challenge field (numeric/hex/alpha, padded per Qxxx) (if “Q”).\nP: password-hash left-padded to the HMAC output length (if PSHAx).  \nS: session_info UTF-8 right-padded to Snnn bytes (if Snnn).\nT: 8-byte big-endian timestamp (if suite contains “T”).\n\n\n\n\n\n","category":"function"},{"location":"api/#OneTimePasswords._dynamic_truncate-Tuple{Vector{UInt8}, Int64}","page":"API","title":"OneTimePasswords._dynamic_truncate","text":"_dynamic_truncate(h::Vector{UInt8}, digits::Int)::String\n\nPerform dynamic truncation (as in HOTP) on the HMAC result h and return the OTP as a zero-padded string of length digits.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords._hmac-Tuple{Symbol, Vector{UInt8}, Vector{UInt8}}","page":"API","title":"OneTimePasswords._hmac","text":"_hmac(algorithm::Symbol, key::Vector{UInt8}, \n    msg::Vector{UInt8})::Vector{UInt8}\n\nCompute the HMAC of msg using key and the selected algorithm. Supported algorithms are :SHA1, :SHA256, and :SHA512.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.base32decode-Tuple{AbstractString}","page":"API","title":"OneTimePasswords.base32decode","text":"base32decode(str::AbstractString)::Vector{UInt8}\n\nDecode a Base32 string (per RFC 4648) into a vector of bytes. The input string is not case sensitive and may contain whitespace or  padding (=). Throws an exception on invalid characters or impossible encoding.\n\nSee also base32encode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.base32encode-Tuple{Vector{UInt8}}","page":"API","title":"OneTimePasswords.base32encode","text":"base32encode(bytes::Vector{UInt8})::String\n\nEncode a byte vector to a Base32 string according to  RFC 4648. Result is always ASCII, using uppercase A-Z and digits 2-7, with = padding.\n\nSee also base32decode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.exportsvg-Tuple{AbstractString}","page":"API","title":"OneTimePasswords.exportsvg","text":"exportsvg(\n  msg::AbstractString;\n  size::Int=240,\n  border::Int=4,\n  path::Union{Nothing,String}=nothing,\n  darkcolor::String=\"#000\",\n  lightcolor::String=\"#fff\"\n)::String\n\nGenerate an SVG <svg>…</svg> QR-code encoding msg. If path is given, also write the SVG to that file.\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> OneTimePasswords.exportsvg(\"otpauth://totp/bob?...\", size=200);\n\nSee also qrcode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.generate-Tuple{HOTP, Vector{UInt8}, Integer}","page":"API","title":"OneTimePasswords.generate","text":"generate(::HOTP, secret::Union{AbstractString,Vector{UInt8}}, \n    counter::Integer; digits::Int=6, algorithm::Symbol=:SHA1)::String\n\nCompute HOTP for secret and counter (RFC 4226).\n\nArguments\n\nsecret: may be either a Base32‐encoded String,   or the raw key bytes as Vector{UInt8}.\ncounter: counter value (Integer).\ndigits: code length (default 6).\nalgorithm: :SHA1, :SHA256, or :SHA512.\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> # Base32-encoded String secret\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\";\n\njulia> generate(HOTP(), secret, 0)\n\"429658\"\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw_secret = OneTimePasswords.base32decode(\n                        \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\");\n\njulia> generate(HOTP(), raw_secret, 0)\n\"429658\"\n\nSee also verify(::HOTP).\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.generate-Tuple{OCRA, Vector{UInt8}}","page":"API","title":"OneTimePasswords.generate","text":"generate(::OCRA, secret::Union{AbstractString,Vector{UInt8}};\n         suite::AbstractString = \"OCRA-1:HOTP-SHA1-6:QN08\",\n         counter::Union{Nothing, Integer}=nothing,\n         challenge::AbstractString=\"\",\n         password::AbstractString=\"\",\n         session_info::AbstractString=\"\",\n         timestamp::Union{Nothing,Integer}=nothing,\n         digits::Int=6,\n         algorithm::Symbol=:SHA1)::String\n\nCompute an OCRA one-time password (OTP) according to RFC 6287.\n\nArguments:\n\nsecret: Base32-encoded shared secret   or the raw key bytes as Vector{UInt8}.\nsuite: OCRA suite definition string.\ncounter: Optional counter value. If omitted, 8 zero bytes are used.\nchallenge: The challenge/question string (e.g. numeric or hex).\npassword: Optional password (P) field.\nsession_info: Optional session information (S) field.\ntimestamp: Optional timestamp (T) as an integer (e.g. Unix time).  \ndigits: The number of digits in the OTP.\nalgorithm: The hash algorithm to use (:SHA1, :SHA256, or :SHA512).\n\nExamples\n\njulia> using OneTimePasswords, Dates\n\njulia> # Base32-encoded String secret\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> code = generate(OCRA(), secret; suite=\"OCRA-1:HOTP-SHA1-6:QN08\",\n            challenge=\"12345678\")\n\"262022\"\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw_secret = OneTimePasswords.base32decode(secret);\n\njulia> code = generate(OCRA(), raw_secret; suite=\"OCRA-1:HOTP-SHA1-6:QN08\",\n            challenge=\"12345678\")\n\"262022\"\n\njulia> secret = \"T6AZ35HKKGWJEUACAUG5MK7T3CBZ5M76Q2GHLMHYOXQEHXKKTATGVH73QBRRW4MBP4P6QKCVMIMMIIBYEY534KZQB6YVK2TE3II3XZA=\"; # generate_secret(63)\n\njulia> suite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\n\njulia> dt = DateTime(2020,1,1,0,0,30);\n\njulia> generate(OCRA(), secret;\n                 suite=suite,\n                 challenge=\"SIG1400000\",\n                 timestamp=dt,\n                 digits=8,\n                 algorithm=:SHA512)\n\"37236432\"\n\nSee also verify(::OCRA).\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.generate-Tuple{TOTP, Vector{UInt8}}","page":"API","title":"OneTimePasswords.generate","text":"generate(::TOTP, secret::Union{AbstractString,Vector{UInt8}};\n         time=nothing, period::Union{Period,Integer}=Second(30), \n         digits::Int=6, algorithm::Symbol=:SHA1)::String\n\nCompute a TOTP value for secret at the specified time (RFC 6238), with integer step-countging.\n\nwarning: Warning\nTOTP (RFC 6238) always uses UTC epoch seconds (since Jan 1, 1970 UTC).   If you pass a DateTime without a timezone, it is assumed to be UTC.   To avoid mismatches, use Dates.now(UTC) or an explicit Unix timestamp.\n\nExamples\n\njulia> using OneTimePasswords, Dates\n\njulia> # Base32-encoded String secret\n\njulia> secret = \"CX6NTW67L7XI3RX7CFUNV4I2ZSXDVSGPLG4KDZ57IJLTM4SOUPNA====\"; # generate_secret(32)\n\njulia> generate(TOTP(), secret; digits=8);\n\njulia> dt = DateTime(2020,1,1,0,0,30);\n\njulia> generate(TOTP(), secret; time=dt, digits=7, period=Second(30), \n           algorithm=:SHA256)\n\"6413619\"\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw_secret = OneTimePasswords.base32decode(secret);\n\njulia> generate(TOTP(), raw_secret; time=dt, digits=7, period=Second(30), \n           algorithm=:SHA256)\n\"6413619\"\n\nSee also verify(::TOTP).\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.generate_secret","page":"API","title":"OneTimePasswords.generate_secret","text":"generate_secret([length::Int=20])::String\n\nGenerate a cryptographically-strong random secret (byte length length) and return it Base32-encoded.  Default is 20 bytes (good for SHA1/TOTP).\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> secret = generate_secret();\n\nSee also base32encode, base32decode.\n\n\n\n\n\n","category":"function"},{"location":"api/#OneTimePasswords.qrcode-Tuple{AbstractString}","page":"API","title":"OneTimePasswords.qrcode","text":"qrcode(\n  uri::AbstractString;\n  format::Union{Symbol,String} = :svg,\n  size::Int = 240,\n  border::Int = 4,\n  path::Union{Nothing,String} = nothing,\n  darkcolor::String = \"#000\",\n  lightcolor::String = \"#fff\"\n)::Union{String,String}\n\nGenerate a QR-code for a provisioning uri.  Supports:\n\nSVG (:svg, returns SVG text),\nBitmap (\"png\", \"jpg\", \"gif\", writes to path) and\nTerminal ASCII (:ascii, prints a scannable QR code in the REPL).\n\nExamples\n\njulia> using OneTimePasswords, Dates\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> code = generate(TOTP(), secret; period=Second(30), digits=6);\n\njulia> verify(TOTP(), secret, code; allowed_drift=Second(30))\ntrue\n\njulia> urilink = uri(TOTP(), secret, \"bob@example.com\", \"MyApp\"; digits=6, \n       period=Second(30));\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \".svg\";\n\njulia> open(tmp_svg, \"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \".png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL\n\nSee also uri and exportsvg.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.uri-Tuple{HOTP, AbstractString, AbstractString, AbstractString}","page":"API","title":"OneTimePasswords.uri","text":"uri(::HOTP, secret::AbstractString,\n    account::AbstractString, issuer::AbstractString;\n    digits::Int=6, counter::Integer=0,\n    algorithm::Symbol=:SHA1)::String\n\nReturn an otpauth://hotp/... provisioning URI for HOTP.\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> uri(HOTP(), secret, \"bob@example.com\", \"MyApp\"; counter=5)\n\"otpauth://hotp/MyApp%3Abob%40example.com?secret=M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF&issuer=MyApp&digits=6&counter=5&algorithm=SHA1\"\n\nSee also qrcode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.uri-Tuple{OCRA, AbstractString, AbstractString, AbstractString}","page":"API","title":"OneTimePasswords.uri","text":"uri(::OCRA, secret::AbstractString,\n    account::AbstractString, issuer::AbstractString;\n    suite::AbstractString=\"OCRA-1:HOTP-SHA1-6:QN08\",\n    digits::Int=6,\n    algorithm::Symbol=:SHA1,\n    counter::Union{Nothing,Int}=nothing,\n    challenge::AbstractString=\"\",\n    password::AbstractString=\"\",\n    session_info::AbstractString=\"\",\n    timestamp::Union{Nothing,Int,DateTime}=nothing\n   )::String\n\nReturn an otpauth://ocra/... provisioning URI for OCRA.\n\nThe label will be issuer:account (percent-escaped), and the query string will include secret, issuer, suite, digits, algorithm, and any of the optional fields you pass in.\n\njulia> using OneTimePasswords\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> uri(OCRA(), secret, \"bob@example.com\", \"MyApp\");\n\njulia> uri(OCRA(), secret, \"alice@site.com\", \"YourOrg\";\n            suite=\"OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1\",\n            digits=8,\n            algorithm=:SHA256,\n            counter=5,\n            challenge=\"12345678\",\n            password=\"7110eda4d09e062aa5e4a390b0a572ac0d2c0220\");\n\nSee also qrcode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.uri-Tuple{TOTP, AbstractString, AbstractString, AbstractString}","page":"API","title":"OneTimePasswords.uri","text":"uri(::TOTP, secret::AbstractString,\n    account::AbstractString, issuer::AbstractString;\n    digits::Int=6, period::Period=Second(30))::String\n\nReturn an otpauth://totp/... provisioning URI for TOTP.\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> uri(TOTP(), secret, \"alice@example.com\", \"MyApp\");\n\njulia> uri(TOTP(), secret, \"bob@site.com\", \"YourApp\"; digits=8, period=60)\n\"otpauth://totp/YourApp%3Abob%40site.com?secret=M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF&issuer=YourApp&digits=8&period=60\"\n\nSee also qrcode.\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.verify-Tuple{HOTP, Vector{UInt8}, Integer, AbstractString}","page":"API","title":"OneTimePasswords.verify","text":"verify(::HOTP, secret::Union{AbstractString,Vector{UInt8}}, \n       counter::Integer, code::AbstractString; digits::Int=6,\n       algorithm::Symbol=:SHA1)::Bool\n\nReturn true if code matches the HOTP for secret and counter.\n\nArguments are the same as for generate(::HOTP).  code is compared in constant time to mitigate timing attacks.\n\nwarning: Warning\nCounter replay: HOTP (RFC 4226) requires that each counter  value MUST be used at most once. This library does not manage  counters; it only checks whether a single code matches. Your  application/server must track and advance the counter and  reject any reused codes to prevent replay attacks.\n\nExamples\n\njulia> using OneTimePasswords\n\njulia> # Base32-encoded String secret\n\njulia> secret = generate_secret();\n\njulia> code = generate(HOTP(), secret, 123; digits=6);\n\njulia> verify(HOTP(), secret, 123, code)\ntrue\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw = OneTimePasswords.base32decode(secret);\n\njulia> code2 = generate(HOTP(), raw, 123);\n\njulia> verify(HOTP(), raw, 123, code2)\ntrue\n\nSee also generate(::HOTP).\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.verify-Tuple{OCRA, Vector{UInt8}, AbstractString}","page":"API","title":"OneTimePasswords.verify","text":"verify(::OCRA, secret::AbstractString, code::AbstractString;\n       suite::AbstractString = \"OCRA-1:HOTP-SHA1-6:QN08\",\n       counter::Union{Nothing, Integer}=nothing,\n       challenge::AbstractString=\"\",\n       password::AbstractString=\"\",\n       session_info::AbstractString=\"\",\n       timestamp::Union{Nothing,Integer,DateTime}=nothing,\n       allowed_drift::Period=Second(0),\n       digits::Int=6,\n       algorithm::Symbol=:SHA1)::Bool\n\nVerify that the provided code matches the OCRA OTP.\n\nExamples\n\njulia> using OneTimePasswords, Dates\n\njulia> # Base32-encoded String secret\n\njulia> secret = generate_secret();\n\njulia> code = generate(OCRA(), secret; challenge=\"12345678\");\n\njulia> verify(OCRA(), secret, code; challenge=\"12345678\")\ntrue\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw_secret = OneTimePasswords.base32decode(secret);\n\njulia> verify(OCRA(), raw_secret, code; challenge=\"12345678\")\ntrue\n\njulia> using OneTimePasswords, Dates\n\njulia> secret = generate_secret();\n\njulia> suite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\n\njulia> dt = DateTime(2020,1,1,0,0,30)\n2020-01-01T00:00:30\n\njulia> secret = \"T6AZ35HKKGWJEUACAUG5MK7T3CBZ5M76Q2GHLMHYOXQEHXKKTATGVH73QBRRW4MBP4P6QKCVMIMMIIBYEY534KZQB6YVK2TE3II3XZA=\"; # generate_secret(63)\n\njulia> code2 = generate(OCRA(), secret;\n                          suite=suite,\n                          challenge=\"SIG1400000\",\n                          timestamp=dt,\n                          digits=8,\n                          algorithm=:SHA512);\n\njulia> verify(OCRA(), secret, code2;\n               suite=suite,\n               challenge=\"SIG1400000\",\n               timestamp=dt + Second(60),\n               allowed_drift=Second(60),\n               digits=8,\n               algorithm=:SHA512)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#OneTimePasswords.verify-Tuple{TOTP, Vector{UInt8}, AbstractString}","page":"API","title":"OneTimePasswords.verify","text":"verify(::TOTP, secret, code::AbstractString;\n       period::Period=Second(30), allowed_drift::Period=Second(30),\n       digits::Int=6, time=nothing,\n       algorithm::Symbol=:SHA1)::Bool\n\nReturn true if code is a valid TOTP for secret at time, allowing ±allowed_drift time window.\n\nwarning: Warning\nTOTP (RFC 6238) always uses UTC epoch seconds (since Jan 1, 1970 UTC).   If you pass a DateTime without a timezone, it is assumed to be UTC.   To avoid mismatches, use Dates.now(UTC) or an explicit Unix timestamp.\n\nwarning: Warning\nAllowed drift window: By default, verification allows ±30 seconds  (one time-step) of drift. Increasing this allowed_drift widens the  acceptance window and makes brute forcing easier. For best security, keep the drift window as small as your deployment can tolerate.\n\nExamples\n\njulia> using OneTimePasswords, Dates\n\njulia> # Base32-encoded String secret\n\njulia> secret = \"M7AB5U4DUCNI4GTUMBMB4QB3LL6RIGOF\"; # generate_secret()\n\njulia> dt = DateTime(2022,1,1,0,0,30);\n\njulia> code = generate(TOTP(), secret; time=dt, digits=8);\n\njulia> verify(TOTP(), secret, code; time=dt, digits=8)\ntrue\n\njulia> verify(TOTP(), secret, code; time=dt+Minute(1), digits=8,\n                           allowed_drift=Second(60))\ntrue\n\njulia> verify(TOTP(), secret, code; time=dt+Minute(1), digits=8,\n                           allowed_drift=Second(30))\nfalse\n\njulia> # secret as `Vector{UInt8}\n\njulia> raw_secret = OneTimePasswords.base32decode(secret);\n\njulia> verify(TOTP(), raw_secret, code; time=dt, digits=8)\ntrue\n\nSee also generate(::TOTP).\n\n\n\n\n\n","category":"method"},{"location":"#OneTimePasswords","page":"Home","title":"OneTimePasswords","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OneTimePasswords.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A minimal, fast Julia module for generating and verifying","category":"page"},{"location":"","page":"Home","title":"Home","text":"counter-based OTP (HOTP, RFC 4226),\ntime-based OTP (TOTP, RFC 6238),\nchallenge-response OTP (OCRA, RFC 6287).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implements RFCs 4226, 6238, and 6287.  Compliance not guaranteed. Not audited.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also provides provisioning URIs and SVG/PNG QR-codes for authenticator apps.","category":"page"},{"location":"#Security-Notice:","page":"Home","title":"Security Notice:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This library is a stateless OTP codec.   It does not enforce rate limiting, account lockouts, throttling, replay prevention, or secure memory handling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is the responsibility of the application or server to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enforce retry limits per user/session\nLock accounts (temporarily or permanently) after repeated failures\nInsert artificial delays or exponential backoff between attempts\nPrevent reuse of OTPs (replay) in the same time window/session\nStore secrets securely in memory and at rest\nAlways use TLS or other secure channels for OTP transport","category":"page"},{"location":"","page":"Home","title":"Home","text":"...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Without these operational measures, your application will be vulnerable to brute-force attacks and OTP replay.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Secrets are returned as Base32-encoded Strings, which are immutable and  cannot be zeroized from memory; for high-assurance systems, use  Vector{UInt8} for secrets and explicitly overwrite them (with fill!)  after use.","category":"page"},{"location":"#Timing-and-Side-Channel-Security","page":"Home","title":"Timing and Side-Channel Security","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OTP code comparisons are performed in constant time, mitigating the most common remote timing side-channel attacks.\nThis package does not guarantee constant-time execution for secret decoding, key handling, or cryptographic operations; it is not designed for hardware tokens, HSMs, or “side-channel hardened” use cases.\nFor most typical server deployments, this is sufficient. For high-assurance applications (e.g., multi-tenant or hostile environments, or where hardware side-channels are a concern), use a hardened cryptography library or a hardware security module (HSM).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OneTimePasswords\")","category":"page"},{"location":"#How-It-Works","page":"Home","title":"How It Works","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OneTimePasswords.jl provides secure one-time password (OTP) workflows based on shared secrets between your server and a user's authenticator app.   The process involves two main stages: Provisioning (Registration) and Verification (Login/Challenge).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provisioning (Registration):\nThe server generates a cryptographically strong secret for each user.\nThis secret is shared with the user, usually by displaying it as a QR code in your client application.\nThe user scans or manually enters this secret in their authenticator app (such as Google Authenticator, Microsoft Authenticator, or FreeOTP).\nThis process securely links their app to your server.\nVerification (Login/Challenge):\nWhen authentication is required, the user generates a code with their authenticator app and submits it through your client application.\nThe server uses OneTimePasswords.jl to verify the submitted code, checking it against the user's stored secret (and time or challenge/counter, depending on the method).\nIf the code is valid, authentication succeeds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OneTimePasswords.jl supports multiple OTP standards:","category":"page"},{"location":"","page":"Home","title":"Home","text":"HOTP: Event/counter-based, the code increments with each use.\nTOTP: Time-based, codes change periodically (e.g., every 30 seconds).\nOCRA: Challenge-response, for complex scenarios like transaction signing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core idea: the secret never leaves the server or user's device after provisioning; only short-lived codes are transmitted during login.","category":"page"},{"location":"#HOTP-Workflow","page":"Home","title":"HOTP Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Registration (Provisioning): The server generates a random secret and creates a provisioning URI (or QR code). The client application displays this QR code or secret, which the user scans or enters into their authenticator app.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authentication (Login): The user requests a one-time code from their authenticator app, which generates a code based on the shared secret and a counter. The user submits this code (along with any identifier) via the client application, which passes it to the server. The server verifies the code using the stored secret and counter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#TOTP-Workflow","page":"Home","title":"TOTP Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Registration (Provisioning): The server generates a random secret and provides a provisioning URI or QR code. The user scans this in their authenticator app to set up time-based codes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authentication (Login): At login, the user opens their authenticator app and reads the current code. The code is entered via the client application and sent to the server, which verifies it using the stored secret and current time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#OCRA-Workflow","page":"Home","title":"OCRA Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Registration (Provisioning): The server generates a secret and OCRA suite definition and makes these available to the user as a QR code or configuration details. The user provisions this in their authenticator app.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authentication (Challenge-Response): For authentication or specific actions (like approving a transaction), the server generates a challenge and presents it to the user. The user inputs the challenge into their authenticator, which generates a response code. The user submits this code (and usually the challenge) back to the application, which forwards it to the server for verification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using OneTimePasswords\n\njulia> secret = generate_secret();\n\njulia> code = generate(HOTP(), secret, 0; digits=6);\n\njulia> verify(HOTP(), secret, 0, code)\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(HOTP(), secret, account, issuer;\n               digits=6, counter=0, algorithm=:SHA1);\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \"hotp.svg\";\n\njulia> open(tmp_svg,\"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \"hotp.png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OneTimePasswords, Dates\n\njulia> secret = generate_secret();\n\njulia> code = generate(TOTP(), secret; period=30, digits=6);\n\njulia> verify(TOTP(), secret, code; allowed_drift=Second(30))\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(TOTP(), secret, account, issuer; digits=6, \n       period=30);\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \".svg\";\n\njulia> open(tmp_svg, \"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \".png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OneTimePasswords, Dates\n\njulia> secret = generate_secret();\n\njulia> suite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\n\njulia> dt = DateTime(2020,1,1,0,0,30)\n2020-01-01T00:00:30\n\njulia> code = generate(OCRA(), secret;\n                          suite=suite,\n                          challenge=\"SIG1400000\",\n                          timestamp=dt,\n                          digits=8,\n                          algorithm=:SHA512);\n\njulia> verify(OCRA(), secret, code;\n               suite=suite,\n               challenge=\"SIG1400000\",\n               timestamp=dt + Second(60),\n               allowed_drift=Second(60),\n               digits=8,\n               algorithm=:SHA512)\ntrue\n\njulia> account = \"alice@example.com\";\n\njulia> issuer  = \"MyApp\";\n\njulia> urilink = uri(OCRA(), secret, \"bob\", \"MyApp\";\n            suite=suite,\n            challenge=\"SIG1400000\",\n            timestamp=dt);\n\njulia> svg = qrcode(urilink; format=:svg, size=200, border=2);\n\njulia> tmp_svg = tempname() * \".svg\";\n\njulia> open(tmp_svg, \"w\") do io\n           write(io, svg)\n       end;\n\njulia> tmp_png = tempname() * \".png\";\n\njulia> pngfile = qrcode(urilink; format=\"png\", path=tmp_png);\n\njulia> isfile(pngfile)\ntrue\n\njulia> # qrcode(urilink; format=:ascii, border=1) # Print in the REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Contributions","page":"Home","title":"Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Questions, issues, and PRs welcome!   See WebAuthn.jl on GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Licensed under the MIT License. See  LICENSE for details.","category":"page"}]
}
